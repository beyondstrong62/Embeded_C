/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>
#include "stm32f446xx.h"

#if !defined(_SOFT_FP) && defined(_ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void ADC_Init()
{
	GPIOA->MODER |= 3<<0; //pa0 analog
	RCC->APB2ENR |= 1<<8; //ENABLE CLOCK //ADC1
	ADC1->SQR1 = 0;//<<1;
	ADC1->CR2 |= (1<<1)|(1<<0);
}
void ADC_EN_Interrupt()
{
	ADC1->CR1 |= (1<<5);
	NVIC_EnableIRQ(ADC_IRQn);
}
void ADC_SOC()
{
	ADC1->CR2 |= (1<<1);
	ADC1->CR2 |= (1<<30);
}
void ADC_value()
{
	ADC1->SR &=(1<<1);
	ADC1->DR |=(1<<0);
}
void ADC_IRQHandler()
{
	if((ADC1->SR & ADC_SR_EOC) != 0)
	{
		ADC1->SR &= ~(1<<1);
		int temp = ADC1->DR;
		printf("%d\n",temp);
		for(uint32_t i=0;i<1600000;i++);
	}
}
void tx_send(int ch)
{
    while (!(USART2->SR & USART_SR_TXE));
    USART2->DR = (ch & 0xFF);
}
int __io_putchar(int ch)
{
	tx_send(ch); // USART2_Transmit function
	for(uint32_t i=0;i<1600000;i++);
	return ch;
}
void Uart2_Init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    GPIOA->MODER &= ~((3 << 4) | (3 << 6));
    GPIOA->MODER |= (2 << 4) | (2 << 6);     // Set mode to alt fun
    GPIOA->OSPEEDR |= (3 << 4) | (3 << 6);   // Set 11 hspeed for PA2 and PA3
    GPIOA->AFR[0] |= (7 << 8) | (7 << 12);   // Set alt fun 7 (AF7) for PA2 and PA3
    // Configure USART2
    USART2->CR1 = 0x00;                      // Clear CR 1
    USART2->CR1 |= (1 << 13);    // Enable USART
    USART2->CR1 &= ~(1 << 12);  // Set word len to 8 bits

    USART2->BRR = (7<<0)|(24<<4);

    USART2->CR1 |= (1 << 2);   // Enable receiver
    USART2->CR1 |= (1 << 3);  // Enable transmitter
}
void clockSpeed_PLL(void)
{
    #define PLL_M  4
    #define PLL_N  180
    #define PLL_P  0  // PLLP = 2

    // 1. Enable HSE and wait for it to be ready
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY));

    // 2. Set the power enable clock and voltage regulator
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
    PWR->CR |= PWR_CR_VOS;

    // 3. Configure flash prefetch, instruction cache, data cache and wait state
    FLASH->ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_5WS;

    // 4. Configure prescalers for AHB, APB1, and APB2
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;    // AHB = SYSCLK / 1
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;   // APB1 = HCLK / 4
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;   // APB2 = HCLK / 2

    // 5. Configure the main PLL
    RCC->PLLCFGR = (PLL_M << 0) | (PLL_N << 6) | (PLL_P << 16) | RCC_PLLCFGR_PLLSRC_HSE;

    // 6. Enable the PLL and wait for it to be ready
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY));

    // 7. Select the PLL as the system clock source
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

int main(void)
{
	clockSpeed_PLL();

	 Uart2_Init(); // this is a function for USART2_Transmit import it from USART Tutorial for reference.
	 ADC_Init(); //
	 ADC_EN_Interrupt(); // this function is for enabling interrupt
	 ADC_SOC();
	 while(1){
	 }
}
